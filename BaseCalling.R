## This script takes as input the .csv file generated by teh ExportMeasurements Module of the accompanying CellProfiler image analysis pipeline
## The data used for this example is in "example_images" folder
## Make sure all the relevant information about the images is in the file name of the images

## Load packages
library(tidyverse)
library(reshape2)
library(tiff)
library(imager)

## ------------------------------------------------------------------------------------------------
## set barcodes used in the experiment
## ------------------------------------------------------------------------------------------------

reference = read.csv("barcodes/reference.csv")

## ------------------------------------------------------------------------------------------------
## Set path to the folder containing the files to be analysed, open the files and extract meta data
## ------------------------------------------------------------------------------------------------

## Set path to the parent folder with the image analysis data
# setwd("")

## Name of the folder containing the files to be analysed
samCond = "example_images"

## Extract the file names of the files to be analysed
filenames = list.files(samCond, pattern = "^b1_b2_b3_", full.names = TRUE, recursive = TRUE)
rawRep_names = lapply(samCond, grep, x = filenames, value = TRUE)

## Collect all the files and concatenate the datasets
rawRep = data.frame()
for (i in 1:lengths(rawRep_names)) {
  print(rawRep_names[[1]][i])
  rr.pre = read.csv(rawRep_names[[1]][i], sep = ",", header = T, stringsAsFactors = F)
  rr.pre$file_name = as.character(rawRep_names[[1]][i])
  print(nrow(rr.pre))
  try({rr.pre$subRegionType = names(rr.pre)[grep("^Parent_.*", names(rr.pre))]})
  colnames(rr.pre) <- sub("^Parent_.*_cells$", "Parent_cells", colnames(rr.pre))
  colnames(rr.pre) <- sub("^Distance_.*_cells$", "Distance_centroid_cells", colnames(rr.pre))
  
  rawRep = rbind(rawRep, rr.pre)
}

rm(rr.pre)

## Extract meta data information from the file name
rawRep$subRegionType = gsub("^Parent_", "", rawRep$subRegionType)
rawRep$subRegionType = gsub("_cells$", "", rawRep$subRegionType)
rawRep$injection_type = str_extract(rawRep$file_name, "LNP|AAV8|AAV9|wt")
rawRep$locus = str_extract(rawRep$file_name, "ACT-V30|TUBBA110")
rawRep$rep_num = str_extract(rawRep$file_name, "rep[0-9]")
rawRep$region_num = str_extract(rawRep$file_name, "reg[0-9]")


## ------------------------------------------------------------------------------------------------
## Keep all the relevent data in a dataframe from the concatenated data files
## ------------------------------------------------------------------------------------------------

chred = rawRep %>% 
  select(contains("Intensity_UpperQuartileIntensity"), Location_Center_X, Location_Center_Y,  Parent_cells, Number_Object_Number, locus, injection_type, rep_num, region_num, subRegionType, starts_with("Distance_Centroid_"), file_name) %>%
   unite(ID, c(locus, injection_type, rep_num, region_num, subRegionType, Number_Object_Number ),sep = "_", remove = F ) %>%
   unite(parentID, c(locus, injection_type, rep_num, region_num, subRegionType, Parent_cells),sep = "_", remove = F )


## ------------------------------------------------------------------------------------------------
## Call the base at each sequencing cycle and calcualte quality
## ------------------------------------------------------------------------------------------------

chred.norm = as.data.frame(chred)

chred.norm$s1 = apply(chred.norm[, endsWith( names(chred.norm), "_b1"   )], 1, sum)
chred.norm$s2 = apply(chred.norm[, endsWith( names(chred.norm), "_b2"   )], 1, sum)
chred.norm$s3 = apply(chred.norm[, endsWith( names(chred.norm), "_b3"   )], 1, sum)

chred.norm$m1 = apply(chred.norm[, endsWith( names(chred.norm), "_b1"   )], 1, max)
chred.norm$m2 = apply(chred.norm[, endsWith( names(chred.norm), "_b2"   )], 1, max)
chred.norm$m3 = apply(chred.norm[, endsWith( names(chred.norm), "_b3"   )], 1, max)

chred.norm$q1 = chred.norm$m1/chred.norm$s1
chred.norm$q2 = chred.norm$m2/chred.norm$s2
chred.norm$q3 = chred.norm$m3/chred.norm$s3

chred.norm$b1.max = names(chred.norm[grep("_b1", colnames(chred.norm))])[max.col(replace(chred.norm[grep("_b1", colnames(chred.norm))], is.na(chred.norm[grep("_b1", colnames(chred.norm))]), -999), 'first')*NA^(rowSums(chred.norm[grep("_b1", colnames(chred.norm))])==0)]
chred.norm$b2.max = names(chred.norm[grep("_b2", colnames(chred.norm))])[max.col(replace(chred.norm[grep("_b2", colnames(chred.norm))], is.na(chred.norm[grep("_b2", colnames(chred.norm))]), -999), 'first')*NA^(rowSums(chred.norm[grep("_b2", colnames(chred.norm))])==0)]
chred.norm$b3.max = names(chred.norm[grep("_b3", colnames(chred.norm))])[max.col(replace(chred.norm[grep("_b3", colnames(chred.norm))], is.na(chred.norm[grep("_b3", colnames(chred.norm))]), -999), 'first')*NA^(rowSums(chred.norm[grep("_b3", colnames(chred.norm))])==0)]

chred.norm$b1.max.base = chred.norm$b1.max
chred.norm$b1.max.base = tolower(chred.norm$b1.max.base)
chred.norm$b1.max.base = gsub(".*_red_b1", "T", chred.norm$b1.max.base)
chred.norm$b1.max.base = gsub(".*_farred_b1", "A", chred.norm$b1.max.base)
chred.norm$b1.max.base = gsub(".*_gold_b1", "G", chred.norm$b1.max.base)
chred.norm$b1.max.base = gsub(".*_cy7_b1", "C", chred.norm$b1.max.base)

chred.norm$b2.max.base = chred.norm$b2.max
chred.norm$b2.max.base = tolower(chred.norm$b2.max.base)
chred.norm$b2.max.base = gsub(".*_red_b2", "T", chred.norm$b2.max.base)
chred.norm$b2.max.base = gsub(".*_farred_b2", "A", chred.norm$b2.max.base)
chred.norm$b2.max.base = gsub(".*_gold_b2", "G", chred.norm$b2.max.base)
chred.norm$b2.max.base = gsub(".*_cy7_b2", "C", chred.norm$b2.max.base)

chred.norm$b3.max.base = chred.norm$b3.max
chred.norm$b3.max.base = tolower(chred.norm$b3.max.base)
chred.norm$b3.max.base = gsub(".*_red_b3", "T", chred.norm$b3.max.base)
chred.norm$b3.max.base = gsub(".*_farred_b3", "A", chred.norm$b3.max.base)
chred.norm$b3.max.base = gsub(".*_gold_b3", "G", chred.norm$b3.max.base)
chred.norm$b3.max.base = gsub(".*_cy7_b3", "C", chred.norm$b3.max.base)


chred.norm$str.call = paste0(chred.norm$b1.max.base, chred.norm$b2.max.base, chred.norm$b3.max.base)

## ------------------------------------------------------------------------------------------------
## Filter by qual
## ------------------------------------------------------------------------------------------------

chred.norm.clean = chred.norm[complete.cases(chred.norm), ]
chred.norm.clean = chred.norm.clean[chred.norm.clean$q1 >= 0.5,]
chred.norm.clean = chred.norm.clean[chred.norm.clean$q2 >= 0.5,]
chred.norm.clean = chred.norm.clean[chred.norm.clean$q3 >= 0.5,]

## ------------------------------------------------------------------------------------------------
## match to reference and extract the match with min hamming distance
## ------------------------------------------------------------------------------------------------

barcode.match = vapply(chred.norm.clean$str.call, function(x) which.min(stringdist::stringdist(x, reference$barcode, method = "hamming")), integer(1L))
barcode.diff = unlist(lapply(chred.norm.clean$str.call, function(x) 
  paste(which(stringdist::stringdist(x, reference$barcode, method = "hamming")  ==  min( stringdist::stringdist(x, reference$barcode, method = "hamming"))), collapse = "-") ))
chred.norm.clean = cbind( chred.norm.clean, data.frame(chred.norm.clean$str.call, barcode=reference$barcode[barcode.match], status= reference$status[barcode.match], barcode.diff))

chred.norm.clean$status[which(grepl("-", chred.norm.clean$barcode.diff))] = NA


## ------------------------------------------------------------------------------------------------
## Calculate the editing efficiency and export the data
## ------------------------------------------------------------------------------------------------

chred.clean.perCellCount = chred.norm.clean %>%
  filter(status == "Unedited" | status == "Edited") %>%
  group_by(parentID, locus, injection_type, rep_num, region_num, subRegionType) %>%
  summarise(genotype = toString(sort(unique(status))),
            num_reads_perCell = n()) %>%
  ungroup()

chred.clean.perCellCount = chred.clean.perCellCount[chred.clean.perCellCount$num_reads_perCell >= 2,]

chred.clean.editTable = chred.clean.perCellCount %>%
  group_by(locus, injection_type, rep_num, region_num, subRegionType, genotype) %>%
  summarise(num_cells_perGenotype = n()) %>%
  ungroup() %>%
  group_by(locus, injection_type, rep_num, region_num, subRegionType) %>%
  mutate(totalCells = sum(num_cells_perGenotype)) %>%
  mutate(percentCells = 100*num_cells_perGenotype/sum(num_cells_perGenotype)) %>%
  ungroup()

chred.clean.editTable = chred.clean.editTable[chred.clean.editTable$totalCells >= 5,]

chred.clean.editTable[,c("genotype", "percentCells")]
write.csv(chred.clean.editTable, paste0(samCond, "_editing_efficiency_table.csv"))

# chred.clean.editTable %>%
#   ggplot(aes(injection_type, percentCells, fill =  subRegionType)) +
#   stat_summary(fun = "mean", geom = "bar", color = "darkgrey", position = "dodge") +
#   geom_point(position = position_dodge(0.8)) + ylim(0,100) +
#   facet_grid(rows = vars(genotype)) + xlab("") + ylab("Cells (%)") +
#   theme_classic() + scale_fill_brewer()

